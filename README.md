# leetcode刷题总结

从第12题开始，不再以leetcode官方顺序来刷题（可能之后会补上），而是找100道最热门的题目来刷

> 原因是部分题目价值较低，甚至有争议

---

在第三题中，我们又遇到了重复字串的问题，需要考虑到的无非是暴力，当然还有一种更为巧妙的算法-> 滑动窗口。

*我们只需要考虑到下一个重复字符出现在哪里，我么就可以重新定义子串的起始位置*

---

在第四题中运用了稀疏数组的思想

如果要将两个空间进行处理然后产生一个新的结构相同的空间，这时候如果想要不增加新的空间，我们通常会将原先的一个空间扩展变成处理后的数据空间容器。

*如果采取这样的方法，我们最好考虑在存储时将处理好的数据放到较为稀疏的一侧（一般就在扩展空间中），在题目中就是从尾部开始放入数据。这样我们就不用担心在处理的过程中反复更改数据空间的结构*

<u>如果再碰到合并有序数组的问题，应该采取这样的算法</u>

---

第五题回文串问题

> 使用动态规划

```
dp[i][j] = dp[i + 1][j - 1] && s[i] === s[j]
```

> 如何确定一个字符子串？

Ans: *起始位置，长度，终止位置，三者知晓其二即可*

---

第六题来说的话，主要是理清楚逻辑

<u>对字符串来说，最重要的是结构为指针(因为字符串本质上也就是数组)。</u>

本题就有两种主要思路：

1. 找规律: 把所有的行的规律找出来

2. 直接按照题目思路来用指针遍历字符串

---

第九题

因为这题只需要判断当前字符串是不是回文，而不像第五题找出所有回文串。这时候我们就不用动态规划了，直接采用中间向两边扩散的方法。

<u>突然发现扩散法太傻了，实际上可以直接不断比较两端的字符是否相等，到中间就停止即可</u>

---

第11题

又到了双指针第题型。在这个题中，我们需要双指针移动到正确到位置从而满足条件，如果是这样的话，我们使用双指针法，需要思考的是怎么确定移动条件。

我们从两边端点开始每次移动较短的一边，查看是否有体积变大的情况(因为如果固定一边随便缩小的话，宽度会变小体积极大情况也会变小)

总结：<u>如果是类似双指针的题目，那么重点就是怎么选取转移条件</u>

---

第15题

这题如果从本质上来说还是一个双指针的题目，只不过难点在于想到需要将数组进行排序。像这种对数组元素大小做文章的题目一定要想到将数组排序降低问题的混乱度
